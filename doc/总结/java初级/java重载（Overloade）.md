## java重载（Overload）



### 1.重载出现的原因

任何程序设计语言都具备的一项重要特性就是对名字的运用。当创建一个对象时，就给对象的存储空间取了一个名字。方法名就是给某个动作取的名字。通过使用名字，我们可以引用所有对象和方法。名字起的好可以使程序更易于理解和修改。

在大多数程序设计语言中要求为每个方法提供唯一的标识符。不能使用print()的函数显示了整数之后，又用一个名为print()的函数显示浮点数。即，**每个函数（方法）都要有唯一的名称。这是迫使出现`重载方法`的理由之一**。若是print()函数可以被重载了，那么就既可以输出整数也可以输出浮点数。或者又可以举例：我们要计算两个整数相加，我们可以设计方法为int add(int a, int b)。调用add(10,10)我们就可以知道是计算两个整数相加。此时，我们又想计算两个浮点数相加，因为add见名知意所以我们继续使用这个名字，那么就需要方法double add(double a, double c)。于是，add()方法就被`重载`了。

**在Java(和C++)里，构造器是强制重载方法出现的另一个原因**。构造器的名字由类名决定，那么就只能有一个构造器。但是，又想使用多种方式创建对象又该怎么办呢？那么就只有重载构造器，使得同名不同参的构造器同时存在。



### 2.重载的规则

方法重载是在一个类里面，方法名相同，而参数不同，对返回值没有强制要求可以相同也可以不同。方法重载需要注意一下几点：

- 被重载的方法必须改变参数列表（参数个数或者类型不一样）
- 被重载的方法介意改变返回类型和访问修饰符
- 被重载的方法可以声明新的或者更广的检查异常
- 方法能够在同一个类中或者在一个子类中被重载
- 不能以返回值类型作为分区重载函数的标准



### 3.区分重载方法

每个重载的方法都有独一无二的参数类型列表。所以在区分重载方法时，只能以类名和方法的形参列表作为标准。

那为什么不能使用方法的返回值来区分呢？

比如下面两个方法，虽然它们有相同的名字和形式参数，但是却很容易区分它们

```java
void f(){}
int f() {return 1;}
```

只要编译器可以根据语境明确判断出语义，比如在int x = f()中，那么的确可以根据此区分方法。不过，有时你并不关心方法的返回值，你想要的是方法调用的其他效果，这时你可能会调用方法而忽略返回值。所以，向下面这样的调用方法：

```java 
f()；
```

此时Java该怎样判断调用的是哪个方法呢？别人也无法理解这个代码的含义。因此，依据方法的返回值来区分重载方法是行不通的。