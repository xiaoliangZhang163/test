# java接口

## 1.接口概念

​    官方解释：Java接口是一系列方法的声明，是一些方法特征的集合，一个接口只有方法的特征没有方法的实现，因此这些方法可以在不同的地方被不同的类实现，而这些实现可以具有不同的行为（功能）。

    我的解释：接口可以理解为一种特殊的类，里面全部是由全局常量和公共的抽象方法所组成。接口是解决Java无法使用多继承的一种手段，但是接口在实际中更多的作用是制定标准的。或者我们可以直接把接口理解为100%的抽象类，既接口中的方法必须全部是抽象方法。（JDK1.8之前可以这样理解）

 


## 2.接口的特点

​    就像一个类一样，一个接口也能够拥有方法和属性，但是在接口中声明的方法默认是抽象的。（即只有方法标识符，而没有方法体）。

 

接口指明了一个类必须要做什么和不能做什么，相当于类的蓝图。
一个接口就是描述一种能力，比如“运动员”也可以作为一个接口，并且任何实现“运动员”接口的类都必须有能力实现奔跑这个动作（或者implement move()方法），所以接口的作用就是告诉类，你要实现我这种接口代表的功能，你就必须实现某些方法，我才能承认你确实拥有该接口代表的某种能力。
如果一个类实现了一个接口中要求的所有的方法，然而没有提供方法体而仅仅只有方法标识，那么这个类一定是一个抽象类。（必须记住：抽象方法只能存在于抽象类或者接口中，但抽象类中却能存在非抽象方法，即有方法体的方法。接口是百分之百的抽象类）
一个JAVA库中接口的例子是：Comparator 接口，这个接口代表了“能够进行比较”这种能力，任何类只要实现了这个Comparator接口的话，这个类也具备了“比较”这种能力，那么就可以用来进行排序操作了。

## 3.为什么要用接口

​    接口被用来描述一种抽象。
因为Java不像C++一样支持多继承，所以Java可以通过实现接口来弥补这个局限。
接口也被用来实现解耦。
接口被用来实现抽象，而抽象类也被用来实现抽象，为什么一定要用接口呢？接口和抽象类之间又有什么区别呢？原因是抽象类内部可能包含非final的变量，但是在接口中存在的变量一定是final，public,static的。

## 4.接口的语法实现

​    为了声明一个接口，我们使用interface这个关键字，在接口中的所有方法都必须只声明方法标识，而不要去声明具体的方法体，因为具体的方法体的实现是由继承该接口的类来去实现的，因此，接口并不用管具体的实现。接口中的属性默认为Public Static Final.一个类实现这个接口必须实现这个接口中定义的所有的抽象方法。

    一个简单的接口就像这样：拥有全局变量和抽象方法。

![1571645804320](C:\Users\zhangxiaoliang\Desktop\总结\1571645804320.png)

    为了实现这个接口，我们使用implements关键词去实现接口：

![1571645763043](C:\Users\zhangxiaoliang\Desktop\总结\1571645763043.png)

其中testClass类实现了我们上面刚才定义的 in1 这个接口，既然你要实现接口，也就是实现接口代表的一种能力，那么你就必须去实现接口给你规定的方法，只有把接口给你规定的抽象方法都给实现了，才承认你这个类实现了这个接口，实现了这个接口代表的某种功能。上图实现了接口中规定的display（）方法。

![1571645733926](C:\Users\zhangxiaoliang\Desktop\总结\1571645733926.png)

    写一个测试类，用来测试一下我们刚才实现的这个接口，因为testclass类的对象t实现了接口规定的display方法，那么自然而然就可以调用display（）方法咯。



    有兴趣的同学可以去这个在线IDE亲自试一试：点击打开链接

 





## 5.接口的进一步理解

我们知道，如果某个设备需要向电脑中读取或者写入某些东西，这些设备一般都是采用USB方式与电脑连接的，我们发现，只要带有USB功能的设备就可以插入电脑中使用了，那么我们可以认为USB就是一种功能，这种功能能够做出很多的事情（实现很多的方法），其实USB就可以看做是一种标准，一种接口，只要实现了USB标准的设备我就认为你已经拥有了USB这种功能。（因为你实现了我USB标准中规定的方法），下面是具体的例子：

先声明USB接口：其中规定了要实现USB接口就必须实现接口规定实现的read( )和write( )这两个方法。

```java
interface USB {
    void read();

    void write();

}
```

然后在写一个U盘类和一个键盘类，这两个类都去实现USB接口。（实现其中的方法）

```java
class YouPan implements USB {
    @Override
    public void read() {
        System.out.println("U盘正在通过USB功能读取数据");
    }
    @Override
    public void write() {
        System.out.println("U盘正在通过USB功能写入数据");
    }
}
```



这是U盘的具体实现。

```java
class JianPan implements USB {
    @Override
    public void read() {
        System.out.println("键盘正在通过USB功能读取数据");
    }
    @Override
    public void write() {
        System.out.println("键盘正在通过USB功能写入数据");
    }
}


```


这是键盘的具体实现。
    那么，现在U盘和键盘都实现了USB功能，也就是说U盘和键盘都能够调用USB接口中规定的方法，并且他们实现的方式都不一样。

我们在写一个测试，来看看具体的实现：

[

```java
public class Main {
    public static void main(String[] args) {
        //生成一个实现可USB接口（标准）的U盘对象
        YouPan youPan = new YouPan();
        //调用U盘的read( )方法读取数据
        youPan.read();
        //调用U盘的write( )方法写入数据
        youPan.write();
        //生成一个实现可USB接口（标准）的键盘对象
        JianPan jianPan = new JianPan();
        //调用键盘的read( )方法读取数据
        jianPan.read();
        //调用键盘的write( )方法写入数据
        jianPan.write();
    }
}
```

 结果如下：

![1571645546371](C:\Users\zhangxiaoliang\Desktop\总结\1571645546371.png)




    感兴趣的同学可以去在线IDE平台自己验证一下：点击打开链接

 

## 6.关于接口的几个重点

1.我们不能直接去实例化一个接口，因为接口中的方法都是抽象的，是没有方法体的，这样怎么可能产生具体的实例呢？但是，我们可以使用接口类型的引用指向一个实现了该接口的对象，并且可以调用这个接口中的方法。因此，上图中最后的方法调用我们还可以这样写：（实际上就是使用了Java中多态的特性）

```java
public class Main {
    public static void main(String[] args) {
        //生成一个实现可USB接口（标准）的U盘对象
        //但是使用一个接口引用指向对象
        //USB接口类引用可以指向一个实现了USB接口的对象
        USB youPan = new YouPan();
        //调用U盘的read( )方法读取数据
        youPan.read();
        //调用U盘的write( )方法写入数据
        youPan.write();
        //生成一个实现可USB接口（标准）的键盘对象
        //但是使用一个接口引用指向对象
        //USB接口类引用可以指向一个实现了USB接口的对象
        USB jianPan = new JianPan();
        //调用键盘的read( )方法读取数据
        jianPan.read();
        //调用键盘的write( )方法写入数据
        jianPan.write();
    }
}     
```

​                                                                                                                                


 2.一个类可以实现不止一个接口。 

3.一个接口可以继承于另一个接口，或者另一些接口，接口也可以继承，并且可以多继承。

4.一个类如果要实现某个接口的话，那么它必须要实现这个接口中的所有方法。

5.接口中所有的方法都是抽象的和public的，所有的属性都是public,static,final的。

6.接口用来弥补类无法实现多继承的局限。

7.接口也可以用来实现解耦。

## 7.接口的通俗理解

前面我们讲多态的时候用“空调”——“遥控器”的方式去理解多态，实际上在上面的的几个重点中的第一条讲的也是多态的实现，比如，我们可以把“节能”作为一种标准，或者说节能就是一个“接口”，这个接口中有一个方法，叫做变频方法，任何空调，如果要称得上叫做节能空调的话，那么必须实现“节能”这个接口，实现“节能”这个接口，也就必须实现“节能”接口中规定实现的“变频”方法，这样才算是真正的实现了“节能”这个接口，实现了“节能”这个功能。

当某个空调实现了“节能”接口后，这个空调就具备了节能的功能，那么我们也可以不用空调类的引用指向空调对象，我们可以直接使用一个“节能”接口类型引用的“遥控器”去指向“空调”，虽然这个“遥控器”上面只有一个按键，只有一个“变频”的方法，但是“遥控器”所指向的空调是实现了“节能”这个接口的，是有“变频”方法的实现的，我们用这个只有一个“变频”方法的遥控器去命令空调调用“变频”方法，也是行得通的，实在不清楚的同学可以去看我的另一篇文章：JAVA之对象的多态性。

## 8.接口的标识用法

​    虽然接口内部定义了一些抽象方法，但是并不是所有的接口内部都必须要有方法，比如Seriallizable接口，Seriallizable接口的作用是使对象能够“序列化”，但是Seriallizable接口中却没有任何内容，也就是说，如果有一个类需要实现“序列化”的功能，则这个类必须去实现Seriallizable接口，但是却并不用实现方法（因为接口中没有方法），此时，这个Serilizable接口就仅仅是一个“标识”接口，是用来标志一个类的，标志这个类具有这个“序列化”功能。具体的实现请参考我的另一篇文章——JAVA之IO流。